# Генератор меню
## Общие представления
1. Шаблоны template/menu_renc.c.j2 template/menu_renc.h.j2 -- внешние. Не в файле python!
2. Создаётся два файла (по умолчанию output/menu_renc.c, output/menu_renc.h, renc -- rotary encoder)
3. При помощи config/menu_config.json программой menu_generator.py с использованием библиотеки jinja2. 
   Объекты меню описываются, как вложенные. Т.е., мы не указываем вручную parent, child, next, prev, e.t.c.
4. В настройках генератора можно указать путь и имя *.h файла меню и путь и имя *.c файла меню,
   но есть пути и имена по умолчанию (имена не из командной строки!). 
5. Лучше указывать все настройки проекта расположить в menu_config.json
6. Генератор на python сделан в виде класса или классов
7. В скрипт встроена проверка на синтаксические ошибки с указанием номера строки, где ошибка и
    проверка связности элементов меню (если какие-то меню ни с кем не связаны сообщаем об этом)
    если цепочка связности нарушена, сообщаем об этом

## Событийная модель
Пока приспособлен только для генерации меню для rotary encoder
Всего 4 cобытия:
1. PUSH_BUTTON -- Если текущее меню -- submenu, переход на уровень ниже (first_child) Если текущее меню EDITABLE, переход в состояние MENU_STATE_EDIT
2. LONG_PUSH_BUTTON -- выход на один уровень вверх если меню submenu, переход в состояние MENU_STATE_NAVIGATION
3. DOUBLE_CLICK_BUTTON -- сброс текущего меню (если оно редактируемое) к состоянию по умолчанию, если текущее меню -- submenu -- сброс на первый child от root
4. CHANGE_POSITION -- если меню в состоянии редактирования MENU_STATE_EDIT, изменяет управляемое значение. Если меню в состоянии MENU_STATE_NAVIGATION, переход вперёд/назад (sibling)
5. Все изменения CHANGE_POSITION обрабатываются функцией void handle_change_position(int8_t delta) в зависимости от типа меню и его состояния (MENU_STATE_NAVIGATION/MENU_STATE_EDIT)
6. Все вызовы PUSH_BUTTON обрабатываются void handle_push_button(void)
7. Все вызовы LONG_PUSH_BUTTON обрабатываются void handle_long_push_button(void)
8. Все вызовы DOUBLE_CLICK_PUSH_BUTTON обрабатываются void handle_long_push_button(void)

## Структура сгенерированного проекта
1. Все данные, относящиеся к навигации, factor, min, max мы будем хранить в отдельном массиве static const menu_data_t s_menu_data
2. Все данные которые изменяются в процессе работы меню хранятся в структуре
static menu_values_t s_menu_values.
Сюда попадают значения factor_idx, value, относящееся к данному меню.
Данные можно получать виду void * по MENU_ID
2. Все изменяемые данные, такие, как factor_idx, value, e.t.c. -- в другом массиве static
2. Формируется таблица enum с ID всех редактируемых элементов меню, по которым можно назначать callback, получать указатель на хранимые данные (void *ptr)
3. Все числовые элементы имеют min, max, default
4. Все элементы с _factor хранят таблицу множителей и тоже min, max, default, default_factor_idx и factor_idx (индекс текущего множителя)
5. Все редактируемые элементы (action_...) имеют возможность назначения callback на изменение значения
6. Может быть элемент action_callback. Без изменения по умолчинию. В callback передаётся ACTION_CHANGE со знаком изменения
7. В сгенерированном файле должна формироваться структура menu_data_t, в которую складываются все данные, которые изменяются и 
    7.1. Создаётся статическая переменная `static menu_data_t s_data = {...};
    7.2. сделать возврат `menu_data_t *menu_get_data(void)`
    7.3. для типов action_int_factor еще хранится factor_id (номер множителя из таблицы множителей)
    7.4. Каждый элемент привязан к элементу меню void *data_ptr, чтобы можно было привязать ко внешнему значению
    7.5. Соответственно, для меню со значениями (action...) есть get_data_ptr(menu_id_t id);

## Всего два состояния:
1. MENU_STATE_NAVIGATION -- переход между соседними элементами меню по CHANGE_POSITION и переход вверх, если есть куда (в root не переходим) по LONG_PUSH_BUTTON, и переходим к first_child, если он есть по PUSH_BUTTON
2. MENU_STATE_EDIT (может быть только у редактируемых типов меню -- action_bool, action_int, action_int_factor)

## Стандартная навигация (submenu)
1. PUSH_BUTTON -- переход к first_child, если он есть. Если нет, ничего не происходит
2. LONG_PUSH_BUTTON -- переход к родителю, если есть куда (в root не переходим, это невидимая нода!)
3. DOUBLE_CLICK_BUTTON -- переход к first_child root
4. CHANGE_POSITION -- перемещаемся в горизонтальном направлении next/prev в зависимости от знака delta = current_position - next_position. Перемещения в горизонтальном меню закольцованы. Если достигнут next == null, переходим к first

## Типы меню:
1. root (возможно, оно должно быть скрыто)
2. submenu (просто отображается в верхней строке). Стандартная навигация. 
3. action_bool (по нажатию PUSH_BUTTON ON/OFF переключаются)
4. action_int (по нажати PUSH_BUTTON ничего не происходит), по CHANGE_POSITION значение изменяется на +-step
5. action_int_factor (по нажатию PUSH_BUTTON выбирается следующий factor из таблицы в колцевом режиме), по CHANGE_POSITION значение изменяется на +-factors[factor_idx];
6. action_float (по нажатию PUSH_BUTTON ничего не происходит), по CHANGE_POSITION значение меняется на +-step
7. action_int_step (по нажатию PUSH_BUTTON ничего не происходит), по CHANGE_POSITION выбирается +-step_idx из таблицы values
8. action_float_step (по нажатию PUSH_BUTTON ничего не происходит), по CHANGE_POSITION выбирается +-step_idx из таблицы values
9. action_callback (по нажатию PUSH_BUTTON ничего не происходит), по CHANGE_POSITION вызывается callback со знаком изменения

## Типы возвращаемых функций `action_callback`
1. ```void change_cb(int8_t delta)``` -- возвращает изменение позиции rotary encoder'а
2. ```void click_cb(void)``` -- отрабатывает коллбэк одиночного нажатия кнопки rotary encoder'а
3. ```void enter_cb(void)``` -- событие входа в меню
4. ```void exit_cb(void)``` -- событие выхода из меню
5. ```const char *display_cb(void)``` -- ОБЯЗАТЕЛЬНЫЙ коллбэк. Возвращает строку, которая будет отображаться во второй строке LCD1602

## Структура конфигурационного файла
### Раздел конфигурации
```javascript
  "config" : {
    "templates" : {
      "menu_source" : "templates/menu.c.j2", // Путь к [JINJA2](https://jinja.palletsprojects.com/en/stable/) шаблону файла menu.c. ОБЯЗАТЕЛЬНОЕ поле
      "menu_header" : "templates/menu.h.j2", // Путь к [JINJA2](https://jinja.palletsprojects.com/en/stable/) шаблона файла menu.h. ОБЯЗАТЕЛЬНОЕ поле
      "callback_header": "templates/callback.h.j2" // Путь к [JINJA2](https://jinja.palletsprojects.com/en/stable/) шаблона файла menu.h. необязательное поле. Создаётся, только если указан этот путь и путь к генерируемому файлу
    },
    "output" : {
      "menu_source" : "../src/rotenc_menu.c", // Путь к генерируемому файлу исходного кода меню. ОБЯЗАТЕЛЬНОЕ поле
      "menu_header" : "../src/rotenc_menu.h", // Путь к генерируемому файлу заголовка меню. ОБЯЗАТЕЛЬНОЕ поле
      "callback_header": "../src/rotenc_callback.h" // Путь к генерируемому файлу заголовков функций обратного вызова. Создаётся если указан путь к шаблону и callback_header. Необязательное поле
    },
    "includes" : [ // #includes, которые будут включены в сгенерированный файл исходного кода меню. Необязательное поле
      "lcd1602.h", 
      "rotenc_callback.h"
    ]
```

### Меню:
```javascript
    "menu" : [

    ] // обязательное поле конфигурационного файла, содержащего пункты меню
```

Для всех вложенных элементов меню ОБЯЗАТЕЛЬНЫ следующие поля:
1. "id" -- без пробелов указывается уникальный идентификатор пункта меню. Будет переведён в верхний регистр и добавлен в ```c enum``` c ID пунктов меню
2. "title" -- Заголовок меню. Не более 14 символов
3. "type" -- может принимать значения:
    a. "action_menu" -- просто пункт меню. Например, "options"
    b. "action_bool" -- пункт меню принимающий значения "On/Off"
    c. "action_int" -- целое число, которое можно изменять от "min" до "max" на "step" при помощи вращающегося переключателя (rotary encoder)
    d. "action_int_factor" -- целое число, которое можно изменять с каждым шагом энкодера от "min" до "max" на текущий множитель (обязательна таблица множителей) умноженный на дельту энкодера (смещение) при помощи вращающегося переключателя (rotary encoder)
    e. "action_float" -- число с плавающей запятой, которое можно изменять на количество шагов энкодера умноженное на step от min до max
    f. "action_float_factor"  -- число с плавающей запятой, которое можно изменять на количество шагов энкодера умноженное на текущий множитель из таблицы множителей от min до max
    g. "action_callback" -- тип меню с функциями обратного вызова. ОБЯЗАТЕЛЬНО задать "display_cb", которая возвращает строку представленную как значение меню (2я строка LCD1602)
4. "children" -- массив подменю. Типы могут быть теми же.

#### `action_menu`
