#include "menu_navigate.h"
#include "menu_struct.h"
#include "menu_engine.h"

typedef struct menu_navigate_context {
    menu_id_t current;
    menu_id_t prev;
} menu_navigate_context_t;

static menu_navigate_context_t s_context = {
    .current = MENU_ID_{{first.id.upper()}},
    .prev = MENU_ID_COUNT
};

// Статические функции
static menu_id_t s_navigate_menu(menu_id_t start_id, int8_t steps, bool backward);

void menu_navigate_sibling(int8_t delta) {
    if (delta == 0) return;
    
    bool is_back = delta > 0;
    int8_t steps = is_back ? delta : -delta;
    
    menu_id_t target_id = s_navigate_menu(s_context.current, steps, is_back);
    
    if (target_id != s_context.current) {
        menu_navigate_to(target_id);
    }
}

void menu_navigate_child(void) {
    menu_id_t target_id = menu_get_child(s_context.current);
    if (target_id == MENU_ID_COUNT)
        return;
    void menu_navigate_to(target_id);
}

void menu_navigate_parent(void) {
    menu_id_t target_id = menu_get_parent(s_context.current);
    if (target_id == MENU_ID_COUNT)
        return;
    menu_navigate_to(target_id);
}

void menu_navigate_to(menu_id_t id) {
    if (id >= MENU_ID_COUNT)
        return;
    s_context.prev = s_context.current;
    s_context.current = id;
    menu_update(s_context.current);
}

// Статические функции
static menu_id_t s_navigate_menu(menu_id_t start_id, int8_t steps, bool backward) {
    menu_id_t current = start_id;
    
    for (int8_t i = 0; i < steps; i++) {
        menu_id_t next_id = backward ? menu_get_prev(current) : menu_get_next(current);
        
        if (next_id == MENU_ID_COUNT) {
            return current; // Останавливаемся на последнем валидном пункте
        }
        current = next_id;
    }
    return current;
}

