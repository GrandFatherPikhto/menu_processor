#include "rotenc_menu.h"
#include <string.h>

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

// Макрос для ограничения значений
#define CLAMP(value, min, max) ((value) < (min) ? (min) : ((value) > (max) ? (max) : (value)))

// Статические массивы для факторов
{% for item_id, item in menu_items.items() if item.type == 'action_int_factor' %}
static const int32_t factors_{{ item_id }}[] = { {{ item.factors | join(", ") }} };
{% endfor %}

// НЕИЗМЕНЯЕМЫЕ данные конфигурации меню
static const menu_item_t s_menu_config[MENU_ID_COUNT] = {
    [MENU_ID_ROOT] = {
        .id = MENU_ID_ROOT,
        .title = "ROOT",
        .type = MENU_TYPE_ROOT,
        .parent = MENU_ID_COUNT,
        .first_child = MENU_ID_{{ first_menu_id }},
        .next_sibling = MENU_ID_COUNT,
        .prev_sibling = MENU_ID_COUNT,
        .first_sibling = MENU_ID_COUNT,
        .last_sibling = MENU_ID_COUNT,
        .config = {0}
    },
    {% for item_id, item in menu_items.items() %}
    [MENU_ID_{{ item_id.upper() }}] = {
        .id = MENU_ID_{{ item_id.upper() }},
        .title = "{{ item.title }}",
        .type = MENU_TYPE_{{ item.type.upper() }},
        .parent = {% if item.parent %}MENU_ID_{{ item.parent.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .first_child = {% if item.first_child %}MENU_ID_{{ item.first_child.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .next_sibling = {% if item.next_sibling %}MENU_ID_{{ item.next_sibling.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .prev_sibling = {% if item.prev_sibling %}MENU_ID_{{ item.prev_sibling.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .first_sibling = {% if item.first_sibling %}MENU_ID_{{ item.first_sibling.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .last_sibling = {% if item.last_sibling %}MENU_ID_{{ item.last_sibling.upper() }}{% else %}MENU_ID_COUNT{% endif %},
        .config = {
            {% if item.type == 'action_int' %}
            .action_int = {
                .min = {{ item.min }},
                .max = {{ item.max }},
                .default_value = {{ item.default }},
                .step = {{ item.step | default(1) }}
            }
            {% elif item.type == 'action_int_factor' %}
            .action_int_factor = {
                .min = {{ item.min }},
                .max = {{ item.max }},
                .default_value = {{ item.default }},
                .factors = factors_{{ item_id }},
                .factors_count = sizeof(factors_{{ item_id }}) / sizeof(factors_{{ item_id }}[0]),
                .default_factor_idx = {{ item.default_factor_idx }}
            }
            {% elif item.type == 'action_bool' %}
            .action_bool = {
                .default_value = {{ 'true' if item.default else 'false' }}
            }
            {% elif item.type == 'action_callback' %}
            .action_callback = {
                .callback = NULL
            }
            {% else %}
            // Пустая структура для других типов
            .action_int = {0}
            {% endif %}
        }
    }{% if not loop.last %},{% endif %}

    {% endfor %}
};

// ИЗМЕНЯЕМЫЕ данные значений меню
static menu_values_t s_menu_values = {
    .values = {
        {% for item_id, item in menu_items.items() %}
        [MENU_ID_{{ item_id.upper() }}] = {
            {% if item.type == 'action_int' %}
            .action_int = {
                .value = {{ item.default }}
            }
            {% elif item.type == 'action_int_factor' %}
            .action_int_factor = {
                .value = {{ item.default }},
                .factor_idx = {{ item.default_factor_idx }}
            }
            {% elif item.type == 'action_bool' %}
            .action_bool = {
                .value = {{ 'true' if item.default else 'false' }}
            }
            {% else %}
            .action_int = {0}
            {% endif %}
        }{% if not loop.last %},{% endif %}

        {% endfor %}
    },
    .current_menu_id = MENU_ID_{{ first_menu_id }},
    .state = MENU_STATE_NAVIGATION
};

// Реализация функций
const menu_item_t *menu_get_config(menu_id_t id) {
    if (id >= MENU_ID_COUNT) return NULL;
    return &s_menu_config[id];
}

menu_values_t *menu_get_values(void) {
    return &s_menu_values;
}

void *menu_get_value_ptr(menu_id_t id) {
    if (id >= MENU_ID_COUNT) return NULL;
    
    const menu_item_t *config = &s_menu_config[id];
    menu_item_values_t *values = &s_menu_values.values[id];
    
    switch (config->type) {
        case MENU_TYPE_ACTION_INT:
            return &values->action_int.value;
        case MENU_TYPE_ACTION_INT_FACTOR:
            return &values->action_int_factor.value;
        case MENU_TYPE_ACTION_BOOL:
            return &values->action_bool.value;
        default:
            return NULL;
    }
}

void handle_change_position(int8_t delta) {
    menu_id_t prev_menu_id = s_menu_values.current_menu_id;

    const menu_item_t *current_config = &s_menu_config[s_menu_values.current_menu_id];
    menu_item_values_t *current_values = &s_menu_values.values[s_menu_values.current_menu_id];
    
    if (s_menu_values.state == MENU_STATE_NAVIGATION) {
        // Навигация между элементами
        menu_id_t target = delta > 0 ? current_config->next_sibling : current_config->prev_sibling;
        if (target != MENU_ID_COUNT) {
            s_menu_values.current_menu_id = target;
        } else {
            // Зацикливание навигации
            if (delta > 0) {
                // Ищем первого sibling
                menu_id_t first_sibling = current_config->parent != MENU_ID_COUNT ? 
                    s_menu_config[current_config->parent].first_child : MENU_ID_COUNT;
                if (first_sibling != MENU_ID_COUNT) {
                    s_menu_values.current_menu_id = first_sibling;
                }
            } else {
                // Ищем последнего sibling
                menu_id_t last_sibling = current_config->parent != MENU_ID_COUNT ? 
                    s_menu_config[current_config->parent].first_child : MENU_ID_COUNT;
                while (last_sibling != MENU_ID_COUNT && 
                       s_menu_config[last_sibling].next_sibling != MENU_ID_COUNT) {
                    last_sibling = s_menu_config[last_sibling].next_sibling;
                }
                if (last_sibling != MENU_ID_COUNT) {
                    s_menu_values.current_menu_id = last_sibling;
                }
            }
            s_menu_values.is_dirty = true;
        }
    } else if (s_menu_values.state == MENU_STATE_EDIT) {
        // Редактирование значения
        switch (current_config->type) {
            case MENU_TYPE_ACTION_INT:
                current_values->action_int.value += delta * current_config->config.action_int.step;
                current_values->action_int.value = CLAMP(current_values->action_int.value,
                    current_config->config.action_int.min, current_config->config.action_int.max);
                s_menu_values.is_dirty = true;
                break;
                
            case MENU_TYPE_ACTION_INT_FACTOR:
                current_values->action_int_factor.value += delta *
                    current_config->config.action_int_factor.factors[current_values->action_int_factor.factor_idx];
                current_values->action_int_factor.value = CLAMP(current_values->action_int_factor.value,
                    current_config->config.action_int_factor.min, current_config->config.action_int_factor.max);
                s_menu_values.is_dirty = true;
                break;
                
            // ... другие типы
        }
    }
}

void handle_push_button(void) {
    const menu_item_t *current_config = &s_menu_config[s_menu_values.current_menu_id];
    menu_item_values_t *current_values = &s_menu_values.values[s_menu_values.current_menu_id];
    
    if (s_menu_values.state == MENU_STATE_NAVIGATION) {
        if (current_config->first_child != MENU_ID_COUNT) {
            // Переход к ребенку
            s_menu_values.current_menu_id = current_config->first_child;
            s_menu_values.is_dirty = true;
        } else if (current_config->type == MENU_TYPE_ACTION_BOOL ||
                   current_config->type == MENU_TYPE_ACTION_INT_FACTOR) {
            // Переход в режим редактирования
            s_menu_values.state = MENU_STATE_EDIT;
            s_menu_values.is_dirty = true;
        }
    } else if (s_menu_values.state == MENU_STATE_EDIT) {
        // Обработка в режиме редактирования
        switch (current_config->type) {
            case MENU_TYPE_ACTION_BOOL:
                current_values->action_bool.value = !current_values->action_bool.value;
                s_menu_values.is_dirty = true;
                break;
                
            case MENU_TYPE_ACTION_INT_FACTOR:
                current_values->action_int_factor.factor_idx =
                    (current_values->action_int_factor.factor_idx + 1) %
                    current_config->config.action_int_factor.factors_count;
                    s_menu_values.is_dirty = true;
                break;
            default:
                break;
        }
    }
}

void handle_long_push_button(void) {
    if (s_menu_values.state == MENU_STATE_EDIT) {
        // Выход из режима редактирования
        s_menu_values.state = MENU_STATE_NAVIGATION;
    } else {
        // Возврат к родителю
        const menu_item_t *current_config = &s_menu_config[s_menu_values.current_menu_id];
        if (current_config->parent != MENU_ID_COUNT && current_config->parent != MENU_ID_ROOT) {
            s_menu_values.current_menu_id = current_config->parent;
        }
    }
    s_menu_values.is_dirty = true;
}

void handle_double_click_button(void) {
    if (s_menu_values.state == MENU_STATE_EDIT) {
        // Сброс к значениям по умолчанию
        const menu_item_t *current_config = &s_menu_config[s_menu_values.current_menu_id];
        menu_item_values_t *current_values = &s_menu_values.values[s_menu_values.current_menu_id];
        
        switch (current_config->type) {
            case MENU_TYPE_ACTION_INT:
                current_values->action_int.value = current_config->config.action_int.default_value;
                break;
            case MENU_TYPE_ACTION_INT_FACTOR:
                current_values->action_int_factor.value = current_config->config.action_int_factor.default_value;
                current_values->action_int_factor.factor_idx = current_config->config.action_int_factor.default_factor_idx;
                break;
            case MENU_TYPE_ACTION_BOOL:
                current_values->action_bool.value = current_config->config.action_bool.default_value;
                break;
        }
    } else {
        // Возврат к первому элементу root
        s_menu_values.current_menu_id = s_menu_config[MENU_ID_ROOT].first_child;
    }
}

void menu_draw(void) {
    const menu_item_t *current_menu = &s_menu_config[s_menu_values.current_menu_id];
    menu_item_values_t *current_values = &s_menu_values.values[s_menu_values.current_menu_id];

    lcd1602_clear();
    
    // Первая строка: заголовок текущего меню
    lcd1602_set_cursor(0, 0);
    lcd1602_print(current_menu->title);

    // Вторая строка: значение или навигация
    lcd1602_set_cursor(0, 1);
    
    switch (current_menu->type) {
        case MENU_TYPE_ACTION_BOOL:
            lcd1602_print(current_values->action_bool.value ? "ON " : "OFF");
            break;
            
        case MENU_TYPE_ACTION_INT: {
            const action_int_config_t *config = &current_menu->config.action_int;
            action_int_values_t *values = &current_values->action_int;
            lcd1602_printf("%d/%d", values->value, config->max);
            break;
        }
            
        case MENU_TYPE_ACTION_INT_FACTOR: {
            const action_int_factor_config_t *config = &current_menu->config.action_int_factor;
            action_int_factor_values_t *values = &current_values->action_int_factor;
            int32_t effective_value = values->value * config->factors[values->factor_idx];
            lcd1602_printf("%d (x%d)", effective_value, config->factors[values->factor_idx]);
            break;
        }
            
        case MENU_TYPE_ACTION_FLOAT: {
            const action_float_config_t *config = &current_menu->config.action_float;
            action_float_values_t *values = &current_values->action_float;
            lcd1602_printf("%.1f/%.1f", values->value, config->max);
            break;
        }
            
        case MENU_TYPE_ACTION_CALLBACK:
            lcd1602_print("Press to run");
            break;
            
        case MENU_TYPE_MENU:
            // Показываем, что это подменю со стрелкой
            lcd1602_print(">");
            break;
            
        default:
            lcd1602_print("");
            break;
    }
    
    // Добавляем индикатор состояния редактирования
    if (s_menu_values.state == MENU_STATE_EDIT) {
        lcd1602_set_cursor(15, 1);  // Правый нижний угол
        lcd1602_print("*");
    }

    s_menu_values.is_dirty = false;
}

bool menu_is_dirty(void)
{
    return s_menu_values.is_dirty;
}