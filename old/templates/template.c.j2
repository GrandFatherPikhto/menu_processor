#include "menu.h"
#include <string.h>

/* Placeholder for LCD functions - replace with real ones */
extern void lcd_clear(void);
extern void lcd_print(const char *s);

/* Generated screens (optional) */
{% for n in flat %}
{% if n.screen %}
static void {{ n.screen_func }}(void) {
    lcd_clear();
    lcd_print("{{ n.title }}");
}
{% endif %}
{% endfor %}

/* Generated action callbacks (if user provided callback name we declare it extern) */
{% for n in flat %}
{% if n.type == 'action_callback' and n.callback %}
extern void {{ n.callback }}(int delta); /* user callback signature */
{% endif %}
{% endfor %}

/* menu table */
const menu_entry_t menu_table[MENU_COUNT] = {
{% for n in flat %}
    { "{{ n.title }}", (menu_id_t){{ n.id }}, {{ n.parent }}, {{ n.child }}, {{ n.next }}, {{ n.prev }}, {{ "ACTION_" + n.enum if n.action else "ACTION_NONE" }}, {{ "SCREEN_" + n.enum if n.screen else "SCREEN_NONE" }} },
{% endfor %}
};

/* menu data storage */
static menu_data_entry_t s_entries[{{ editable_count }}] = {
{% for e in data_entries %}
   { (menu_id_t){{ e.id }}, {{ e.type }}, { .{{ e.val_field }} = {{ e.val }} }, {{ e.min }}, {{ e.max }}, {{ e.step }}, {{ e.factor_idx }} },
{% endfor %}
};

static menu_data_t s_data = {
    .entries = {
        {% for e in data_entries %} s_entries[{{ loop.index0 }}],{% endfor %}
    }
};

menu_data_t *menu_get_data(void) {
    return &s_data;
}

void *menu_get_data_ptr(menu_id_t id) {
    for (size_t i=0;i<{{ editable_count }};++i) {
        if (s_data.entries[i].id == id) {
            switch (s_data.entries[i].type) {
                case MD_TYPE_BOOL: return &s_data.entries[i].value.b;
                case MD_TYPE_INT:  return &s_data.entries[i].value.i;
                case MD_TYPE_FLOAT: return &s_data.entries[i].value.f;
                default: return NULL;
            }
        }
    }
    return NULL;
}

/* display */
void menu_show(menu_id_t id) {
    /* find entry quickly: menu_table[id] exists */
    if ((int)id < 0 || (int)id >= MENU_COUNT) return;
    const menu_entry_t *e = &menu_table[id];
    if (e->screen != SCREEN_NONE) {
        /* find generated screen function: name is screen_{enum} */
        {% for n in flat %}
        if (id == (menu_id_t){{ n.id }}) {
            {% if n.screen %}
            {{ n.screen_func }}();
            {% else %}
            lcd_clear();
            lcd_print("{{ n.title }}");
            {% endif %}
            return;
        }
        {% endfor %}
    } else {
        lcd_clear();
        lcd_print(e->title);
    }
}

/* action dispatcher */
void menu_action(menu_id_t id) {
    {% for n in flat %}
    if (id == (menu_id_t){{ n.id }}) {
        {% if n.type == 'action_bool' %}
        /* toggle bool */
        {
            void *p = menu_get_data_ptr(id);
            if (p) {
                bool *b = (bool*)p;
                *b = !(*b);
            }
        }
        {% elif n.type == 'action_int' %}
        /* nothing on push */
        {% elif n.type == 'action_int_factor' %}
        /* cycle factor */
        {
            /* find entry */
            for (size_t i=0;i<{{ editable_count }};++i){
                if (s_data.entries[i].id == id) {
                    int fcount = {{ factors_map[n.factor_enum].len if n.factor_enum in factors_map else 0 }};
                    if (fcount>0) {
                        s_data.entries[i].factor_idx++;
                        if (s_data.entries[i].factor_idx >= fcount) s_data.entries[i].factor_idx = 0;
                    }
                    break;
                }
            }
        }
        {% elif n.type == 'action_callback' and n.callback %}
        /* call user callback with zero change (enter) */
        {{ n.callback }}(0);
        {% endif %}
        return;
    }
    {% endfor %}
}

/* navigation helpers */
menu_id_t menu_next(menu_id_t current) {
    int n = menu_table[current].next;
    if (n == -1) {
        /* wrap to first sibling */
        int p = menu_table[current].parent;
        if (p == -1) return current;
        int first = menu_table[p].child;
        return (menu_id_t)first;
    }
    return (menu_id_t)n;
}

menu_id_t menu_prev(menu_id_t current) {
    int p = menu_table[current].prev;
    if (p == -1) {
        /* wrap to last sibling */
        int parent = menu_table[current].parent;
        if (parent == -1) return current;
        /* find last sibling */
        int cur = menu_table[parent].child;
        int last = cur;
        while (cur != -1 && menu_table[cur].next != -1) {
            cur = menu_table[cur].next;
            last = cur;
        }
        return (menu_id_t)last;
    }
    return (menu_id_t)p;
}

menu_id_t menu_enter(menu_id_t current) {
    int child = menu_table[current].child;
    if (child != -1) return (menu_id_t)child;
    /* execute action if exists */
    if (menu_table[current].action != ACTION_NONE) {
        menu_action(current);
    }
    return current;
}

menu_id_t menu_back(menu_id_t current) {
    int p = menu_table[current].parent;
    if (p != -1) return (menu_id_t)p;
    return current;
}

/* global navigation state */
static menu_id_t s_current = (MENU_{{ root_id_enum }});
static enum { MENU_STATE_NAVIGATION=0, MENU_STATE_EDIT=1 } s_state = MENU_STATE_NAVIGATION;

/* helper to find data entry index by id */
static int find_entry_idx(menu_id_t id) {
    for (int i=0;i<{{ editable_count }};++i) if (s_data.entries[i].id == id) return i;
    return -1;
}

/* handle change position (delta positive -> forward, negative -> backward) */
void handle_change_position(int8_t delta) {
    if (s_state == MENU_STATE_EDIT) {
        int idx = find_entry_idx(s_current);
        if (idx < 0) return;
        menu_data_entry_t *en = &s_data.entries[idx];
        if (en->type == MD_TYPE_INT) {
            if (en->factor_idx >= 0) {
                /* apply factor table */
                /* NOTE: we assume factor table exists and is FACTORS_<enum> */
                int32_t factor = FACTORS_{{ factors_map[en.factor_enum].enum }}[en->factor_idx];
                int32_t v = en->value.i + delta * factor;
                if (v < en->min) v = en->min;
                if (v > en->max) v = en->max;
                en->value.i = v;
            } else {
                int32_t v = en->value.i + delta * en->step;
                if (v < en->min) v = en->min;
                if (v > en->max) v = en->max;
                en->value.i = v;
            }
        } else if (en->type == MD_TYPE_BOOL) {
            en->value.b = !en->value.b;
        } else if (en->type == MD_TYPE_FLOAT) {
            float fv = en->value.f + delta * ((float)en->step);
            if (fv < (float)en->min) fv = (float)en->min;
            if (fv > (float)en->max) fv = (float)en->max;
            en->value.f = fv;
        }
    } else { /* navigation */
        if (delta > 0) s_current = menu_next(s_current);
        else if (delta < 0) s_current = menu_prev(s_current);
        menu_show(s_current);
    }
}

/* push button */
void handle_push_button(void) {
    /* if submenu -> enter child if exists, else nothing; if editable -> enter edit */
    const menu_entry_t *e = &menu_table[s_current];
    if (e->child != -1) {
        s_current = (menu_id_t)e->child;
        s_state = MENU_STATE_NAVIGATION;
    } else {
        /* if editable */
        int idx = find_entry_idx(s_current);
        if (idx >= 0) {
            s_state = MENU_STATE_EDIT;
        } else {
            /* execute action if available */
            if (e->action != ACTION_NONE) menu_action(s_current);
        }
    }
    menu_show(s_current);
}

/* long push - go back parent if exists; also exit edit mode */
void handle_long_push_button(void) {
    if (s_state == MENU_STATE_EDIT) {
        s_state = MENU_STATE_NAVIGATION;
    } else {
        const menu_entry_t *e = &menu_table[s_current];
        if (e->parent != -1) {
            s_current = (menu_id_t)e->parent;
        }
    }
    menu_show(s_current);
}

/* double click - reset editable to default or go to root->first child */
void handle_double_click_push_button(void) {
    int idx = find_entry_idx(s_current);
    if (idx >= 0) {
        /* reset this entry to default (we stored defaults in generated s_entries) */
        /* copy defaults from initial s_entries (s_entries is initial) */
        /* For simplicity, we do nothing here; you can implement storing defaults separately */
    } else {
        /* go to root first child */
        s_current = (menu_id_t){{ root_id }};
        if (menu_table[s_current].child != -1) s_current = (menu_id_t)menu_table[s_current].child;
    }
    menu_show(s_current);
}
