{% if function_info.event_type == "click" %}
/** @brief Функция для изменения простого числового типа при помощи множителя.
  * Здесь обрабатывается клик.
  * Изменение значение изменяется пропорционально выбранному значению factor
  * Если control == click, то navigation _только_ cycle. И для factor клик меняет
  * индекс factor (множителя) из массива factors
  * @param id Идентификтор меню Определён, в enum в menu_struct.h
  * @param delta Количество "щелчков" энкодера. Передаётся только если control==position
  * {{function_info.event_type}}
  */
void {{function_name}}(menu_context_t *ctx, menu_id_t id) {
    uint8_t *idx  = &(ctx->values[id].data.{{function_info.category}}.idx);
    uint8_t count = ctx->configs[id].data.{{function_info.category}}.count;
    uint8_t old_idx = *idx;

    if ((*idx + 1) >= count) {
        *idx = 0;
    } else {
        *idx = *idx + 1;
    }

    if (*idx != old_idx) {
        ctx->dirty = true;
    }
}

{% elif function_info.event_type == "position" %}{# control==position для factor позиция обрабатывает ТОЛЬКО значение поля #}
/** @brief Функция для изменения простого числового типа при помощи множителя.
  * Здесь обрабатывается позиция энкодера. 
  * Изменение значение изменяется пропорционально выбранному значению factor
  * Значение value может изменяться по кругу, т.е., достигнув максимального значения max становится min
  * Достигнув минимального значения min становится max
  * @param id Идентификтор меню Определён, в enum в menu_struct.h
  * @param delta Количество "щелчков" энкодера. Передаётся только если control==position
  * {{function_info.event_type}}
  */
void {{function_name}}(menu_context_t *ctx, menu_id_t id, int8_t delta) {
    uint8_t *idx  = &(ctx->values[id].data.{{function_info.category}}.idx);
    {{function_info.c_type}} *value  = &(ctx->values[id].data.{{function_info.category}}.value);
    {{function_info.c_type}}  min    = ctx->configs[id].data.{{function_info.category}}.min;
    {{function_info.c_type}}  max    = ctx->configs[id].data.{{function_info.category}}.max;
    {{function_info.c_type}}  factor = ctx->configs[id].data.{{function_info.category}}.factors[*idx];
    {{function_info.c_type}}  old_value = *value;
{% if function_info.navigate == "limit" %}{# navigate limit #}
    if (delta > 0) {
        // Увеличение с проверкой переполнения
        if (*value <= max - (uint32_t)(delta * factor)) {
            *value += delta * factor;
        } else {
            *value = max;
        }
    } else {
        // Уменьшение с проверкой underflow
        if (*value >= min + (uint32_t)(-delta * factor)) {
            *value += delta * factor;  // delta отрицательный
        } else {
            *value = min;
        }
    }
{% elif function_info.navigate == "cyclic" %}{# navigate cyclic #}
    // Если нет изменений или factor = 0 - выходим
    if (delta == 0 || factor == 0) {
        return;
    }

    // Вычисляем диапазон
    uint32_t range = max - min + 1;
    
    // Вычисляем изменение с учётом множителя
    int64_t change = (int64_t)delta * (int64_t)factor;
    
    // Вычисляем новое значение с зацикливанием
    int64_t new_value = (int64_t)*value + change;
    
    // Нормализуем значение в диапазоне [min, max] с зацикливанием
    if (new_value < (int64_t)min) {
        // Если ушли ниже min - переходим к max
        int64_t underflow = (int64_t)min - new_value - 1;
        new_value = (int64_t)max - (underflow % range);
    } else if (new_value > (int64_t)max) {
        // Если превысили max - переходим к min
        int64_t overflow = new_value - (int64_t)max - 1;
        new_value = (int64_t)min + (overflow % range);
    }
    
    // Присваиваем новое значение
    *value = (uint32_t)new_value;
{% endif %}{# navigate #}
    if (*value != old_value) {
        ctx->dirty = true;
    }
}
{% endif %}{# event_type #}
