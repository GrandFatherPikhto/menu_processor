{% if function_info.event_type == "click" %}
/** @brief Функция для фиксированных наборов значений
  * Последующее или предыдущее значение берётся из массива values
  * Если control == click, то navigation _только_ cycle.
  * @param id Идентификтор меню Определён, в enum в menu_struct.h
  * @param delta Количество "щелчков" энкодера. Передаётся только если control==position
  */
void {{function_name}}(menu_context_t *ctx, menu_id_t id) {
    uint8_t *idx  = &(ctx->values[id].data.{{function_info.category}}.idx);
    uint8_t old_idx = *idx;
    uint8_t count = ctx->configs[id].data.{{function_info.category}}.count;
    if (count == 0) {
       return; // Или установите idx в 0
    }

    if (count - 1 > *idx) {
        *idx = *idx + 1;
    } else {
        *idx = 0;
    }

    if (*idx != old_idx) {
        ctx->dirty = true;
    }
}
{% elif function_info.event_type == "position" %}
void {{function_name}}(menu_context_t *ctx, menu_id_t id, int8_t delta) {
    uint8_t *idx  = &(ctx->values[id].data.{{function_info.category}}.idx);
    uint8_t old_idx = *idx;
    uint8_t count = ctx->configs[id].data.{{function_info.category}}.count;
    if (count == 0) {
       return; // Или установите idx в 0
    }
{% if function_info.navigate == "limit" %}
    if (delta > 0) {
        if (*idx + delta < count) {
            *idx = *idx + delta;
        } else {
            *idx = count - 1;
        }
    }

    if (delta < 0) {
        if (*idx >= -delta) {
            *idx = *idx + delta;
        } else {
            *idx = 0;
        }
    }
{% elif function_info.navigate == "cyclic" %}
    if (delta > 0) {
        if (delta + *idx < count) {
            *idx = *idx + delta;
        } else {
            *idx = 0;
        }
    }

    if (delta < 0) {
        if (*idx >= -delta) {
            *idx = *idx + delta;
        } else {
            *idx = count - 1;
        }
    }
{% endif %}{# navigate #}
    if (*idx != old_idx) {
        ctx->dirty = true;
    }
}
{% endif %}{# event_type #}