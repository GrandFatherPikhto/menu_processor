/** @brief Функция для простейших численных типов.
  * Если control == click, то navigation _только_ cycle.
{% if function_info.navigate == "cyclic" %}
  * Значения зациклены. Достигнув max переходят в min, достигнув min переходят в max
{% elif function_info.navigate == "limit" %}
  * Значения не зациклены. Достигнув max значение остаётся max, 
  * достигнув min значение останется min, пока не поменяем направление вращения энкодера
{% endif %}
  * @param id Идентификтор меню Определён, в enum в menu_struct.h
  * @param delta Количество "щелчков" энкодера. Передаётся только если control==position
  */
{% if function_info.event_type == "click" %}
void {{function_name}}(menu_context_t *ctx, menu_id_t id) {
    {{function_info.c_type}} *value  = menu_value_get_{{function_info.category}}_value(ctx, id);
    {{function_info.c_type}}  step = menu_config_get_{{function_info.category}}_step(ctx, id);
    {{function_info.c_type}}   min = menu_config_get_{{function_info.category}}_min(ctx, id);
    {{function_info.c_type}}   max = menu_config_get_{{function_info.category}}_max(ctx, id);
    {{function_info.c_type}} old_value = *value;
    if ((*value + step) > max)
      *value = min;
    else
      *value = *value + step;
    if (*value != old_value) {
      menu_context_set_dirty(ctx);
    }
}
{% elif function_info.event_type == "position" %}
void {{function_name}}(menu_context_t *ctx, menu_id_t id, int8_t delta) {
    {{function_info.c_type}} *value  = menu_value_get_{{function_info.category}}_value(ctx, id);
    {{function_info.c_type}}  step = menu_config_get_{{function_info.category}}_step(ctx, id);
    {{function_info.c_type}}   min = menu_config_get_{{function_info.category}}_min(ctx, id);
    {{function_info.c_type}}   max = menu_config_get_{{function_info.category}}_max(ctx, id);
    {{function_info.c_type}} old_value = *value;  
{% if function_info.navigate == "limit" %}{# navigate limit #}
    if (delta > 0) {
      if ((*value + step * delta) > max) {
        *value = max;
      } else {
        *value = *value + step * delta;
      }
    }

    if (delta < 0) {
      if ((*value + step * delta) < min) {
        *value = min;
      } else {
        *value = *value + step * delta;
      }
    }
{% elif function_info.navigate == "cyclic" %}{# navigate cyclic #}
    if (delta > 0) {
      if ((*value + step * delta) > max) {
        *value = min;
      } else {
        *value = *value + step * delta;
      }
    }

    if (delta < 0) {
      if ((*value + step * delta) < min) {
        *value = max;
      } else {
        *value = *value + step * delta;
      }
    }
{% endif %}{# navigate #}
    if (*value != old_value) {
      menu_context_set_dirty(ctx);
    }
}
{% endif %}{# event_type #}
